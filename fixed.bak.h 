#include <locale>
#include <cmath>
#include <vector>
#include <sstream>
#include <iomanip>

class fixed final
{
private:
    static const int fractional_bits = 16;
    static const int fixed_type_bits = 32;
    static const int fractional_mask = 0xffff;
    
    typedef uint32_t fixed_type;
    typedef uint64_t expand_type;
    
    fixed_type value;

    uint32_t _pow(uint32_t x, uint32_t p)
    {
      if (p == 0) return 1;
      if (p == 1) return x;
 
      uint32_t tmp = _pow(x, p/2);
      if (p%2 == 0) return tmp * tmp;
      else return x * tmp * tmp;
    }

    fixed_type fixed_mult(fixed_type inp_1, fixed_type inp_2) const
    {
        return (fixed_type)(((expand_type)inp_1 * (expand_type)inp_2) >> fractional_bits);
    }

    fixed_type fixed_div(fixed_type inp_1, fixed_type inp_2) const
    {
        return (fixed_type)(((expand_type)inp_1 * (1 << fractional_bits))/ (expand_type)inp_2);
    }

    fixed_type fixed_add(fixed_type inp_1, fixed_type inp_2) const
    {
        fixed_type inp_1_sign = inp_1 >> (fixed_type_bits - 1);
        fixed_type inp_2_sign = inp_2 >> (fixed_type_bits - 1);
        fixed_type add = inp_1 + inp_2;
        fixed_type add_sign = add >> (fixed_type_bits - 1);

        if (inp_1_sign != inp_2_sign)
        {
            return add;
        }
        else if (add_sign == inp_1_sign)
        {
            return add;
        }
        else if (add_sign == -1)
        {
            return ((1 << (fixed_type_bits - 2)) - 1 + (1 << (fixed_type_bits - 2)));
        }
        else if (add_sign == 1)
        {
            return (1 << (fixed_type_bits - 1));
        }
        return 0;
    }
    fixed_type fixed_sub(fixed_type inp_1, fixed_type inp_2) const
    {
        fixed_type inp_1_sign = inp_1 >> (fixed_type_bits - 1);
        fixed_type inp_2_sign = inp_2 >> (fixed_type_bits - 1);
        fixed_type sub = inp_1 - inp_2;
        fixed_type sub_sign = sub << (fixed_type_bits - 1);

        if (inp_1_sign != inp_2_sign)
        {
            return sub;
        }
        else if (sub_sign == inp_1_sign)
        {
            return sub;
        }
        else if (sub_sign == -1)
        {
            return ((1 << (fixed_type_bits - 2)) - 1 + (1 << (fixed_type_bits - 2)));
        }
        else if (sub_sign == 1)
        {
            return (1 << (fixed_type_bits - 1));
        }
        return 0;
    }
    fixed_type fromFloat(float value)
    {
      /*
      fixed_type result = *(fixed_type*)&value;
      uint_fast8_t exponent = (result >> 23) & 0xff;
      bool n = (result & 0x80000000);
      result = result & 0x007fffff;
      int8_t shift = (127 + fractional_bits - 9 - exponent);
      if(shift > 0)
        result >>= shift;
      else
        result <<= -shift;
      shift = (15 - (shift + 9) + fractional_bits + 1);
      result |= 1 << shift;
      if(n)
      {
          int32_t temp = ((result & 0xffff0000) >> 16);
          result = ((~--temp) << 16) + (result & 0x0000ffff);
      }
      return result;
      */
      fixed_type r_result = 0;
      uint32_t t_result = *(uint32_t*)&value;
      int_fast8_t exponent = 127-((t_result >> 23)&0xff);
      if((exponent >= 32) || (exponent <= -32))
        return 0;
      std::cout << "exponent is " << (int)exponent << std::endl;
      bool n = (t_result & 0x80000000);
      t_result = (t_result&0x007fffff)|(1<<23);
      std::cout << "mantissa 1 is " << (int)t_result << std::endl;
      r_result = t_result >> (7+exponent);
      std::cout << "mantissa 2 is " << (int)t_result << std::endl;
      if(n)
      {
          //r_result = (((~r_result)&0xFFFF0000)|(r_result&0xFFFF))/*+0x10000*/;
          r_result = -r_result;
      }
      std::cout << "mantissa 3 is " << (int)t_result << std::endl;
      return r_result;
      
    }
public:
    fixed() {}
    fixed(float value)
    {
      this->value = fromFloat(value);
      //this->value = (fixed_type)(value * (1 << fractional_bits)); // не работает блеать
    }
    fixed(double value)
    {
      *this = (float)value;
    }
    fixed(int value)
    {
      this->value = (fixed_type)((expand_type)value * (1 << fractional_bits));
    }
    static fixed fromRaw(fixed_type value)
    {
      fixed result;
      result.value = value;
      return result;
    }
    int16_t toInt() const
    {
      return (value >> fractional_bits);
    }
    int32_t toRaw() const
    {
      return value;
    }
    float toFloat()
    {
     /*
      // экспонента числа с плавающей точкой 
      fixed_type _value = value;
      uint_fast8_t exponent = 127 + fractional_bits - 9;
      
      if(_value != 0)
      {
        bool n = (_value & 0x80000000);
        if(n)
        {
          int16_t temp = ((_value & 0xffff0000) >> 16);
          _value = ((~--temp) << 16) + (_value & 0x0000ffff);
        }

        if((_value & 0xff000000))
        {
          while((_value & 0xff000000) != 0)
          {
            _value >>= 1;
            exponent++;
          }
        }
        else
        {
          _value &= 0x007fffff;
          while((_value & 0xff800000) == 0)
          {
            _value <<= 1;
            exponent--;
          }
        }

        _value &= 0x007fffff;
        _value |= exponent << 23;
        if(n) _value |= 0x80000000;
      }
      return *(float*)&_value;
     */
      //return (int)value/65535.;
     
      // экспонента числа с плавающей точкой
      uint_fast8_t exponent = 134;

       bool n = (value & 0x80000000);
        if(n)
          value = -value;

      if(value != 0)
      {
          if(value & 0xff000000)
          {
              while(value & 0xff000000)
              {
                  value >>= 1;
                  exponent ++;
              }
          }
          else
          {
              while((value & 0xff800000) == 0)
              {
                  value <<= 1;
                  exponent --;
              }
          }
          value &= 0x007fffff;
          
          value |= (uint32_t)exponent << 23;
      }
      return n?(*(float*)&value*(-1)):(*(float*)&value);
      //return (n==true)?5:1;
      
    }
    static fixed fromString(const std::string& stringValue)
    {
      std::vector<std::string> token_v;
      fixed result;
      char decimal_point = std::use_facet< std::numpunct<char> >(std::cout.getloc()).decimal_point();
      size_t start = stringValue.find_first_not_of(decimal_point), end=start;

      while (start != std::string::npos){
        end = stringValue.find(decimal_point, start);
        token_v.push_back(stringValue.substr(start, end-start));
        start = stringValue.find_first_not_of(decimal_point, end);
      }

      if(token_v.size() > 2 || token_v.empty())
      {
        throw "invalid_argument";
      }

      result.value = (std::stoi(token_v.at(0)) << fractional_bits);
      if(token_v.size() > 1)
      {
        uint32_t fr_size = result._pow(10, token_v.at(1).size());
        result.value |= ((std::stoi(token_v.at(1)) << fractional_bits) / fr_size);
      }
      return result;
    }
    std::string toString(int precision = 2)
    {
      std::stringstream result;
      if(!(precision &= 7)) precision = 2;
      int16_t integer = value >> fractional_bits;
      uint64_t fr_size = _pow(10, precision + 1);
      uint64_t fraction = (((value & fractional_mask) * fr_size) >> fractional_bits);
      if((fraction % 10) >= 5)
      {
        fraction += 10;
      }
      fraction /= 10;
      result << integer;
      if(fraction)
      {
        char decimal_point = std::use_facet< std::numpunct<char> >(std::cout.getloc()).decimal_point();
        result  << decimal_point << std::setw(precision) << std::setfill('0') << fraction;
      }
      return result.str();
    }
    // бинарные
    friend fixed& operator+=(fixed& lv, const fixed& rv);
    friend fixed& operator-=(fixed& lv, const fixed& rv);
    friend fixed& operator*=(fixed& lv, const fixed& rv);
    friend fixed& operator/=(fixed& lv, const fixed& rv);
    friend const fixed operator-(const fixed& lv, const fixed& rv);
    friend const fixed operator+(const fixed& lv, const fixed& rv);
    friend const fixed operator-(const fixed& lv, int rv);
    friend const fixed operator+(const fixed& lv, int rv);
    friend const fixed operator-(const fixed& lv, float rv);
    friend const fixed operator+(const fixed& lv, float rv);
    friend const fixed operator-(const fixed& lv, double rv);
    friend const fixed operator+(const fixed& lv, double rv);
    friend const fixed operator-(int lv, const fixed& rv);
    friend const fixed operator+(int lv, const fixed& rv);
    friend const fixed operator-(float lv, const fixed& rv);
    friend const fixed operator+(float lv, const fixed& rv);
    friend const fixed operator-(double lv, const fixed& rv);
    friend const fixed operator+(double lv, const fixed& rv);
    friend const fixed operator*(int lv, const fixed& rv);
    friend const fixed operator/(int lv, const fixed& rv);
    friend const fixed operator*(float lv, const fixed& rv);
    friend const fixed operator/(float lv, const fixed& rv);
    friend const fixed operator*(double lv, const fixed& rv);
    friend const fixed operator/(double lv, const fixed& rv);
    friend const fixed operator*(const fixed& lv, const fixed& rv);
    friend const fixed operator/(const fixed& lv, const fixed& rv);
    friend const fixed operator*(const fixed& lv, int rv);
    friend const fixed operator/(const fixed& lv, int rv);
    friend const fixed operator*(const fixed& lv, float rv);
    friend const fixed operator/(const fixed& lv, float rv);
    friend const fixed operator*(const fixed& lv, double rv);
    friend const fixed operator/(const fixed& lv, double rv);
    // перегрузка преобразования типа
    operator float()/* const*/
    {
      return float(toFloat());
    }
    explicit operator int() const
    {
      return float(toInt());
    }
};

const fixed operator-(const fixed& lv, const fixed& rv) {
   return fixed::fromRaw(lv.fixed_sub(lv.value, rv.value));
}
const fixed operator+(const fixed& lv, const fixed& rv) {
   return fixed::fromRaw(lv.fixed_add(lv.value, rv.value));
}
const fixed operator-(const fixed& lv, int rv) {
   return lv - fixed(rv);
}
const fixed operator+(const fixed& lv, int rv) {
   return lv + fixed(rv);
}
const fixed operator-(const fixed& lv, float rv) {
   return lv - fixed(rv);
}
const fixed operator+(const fixed& lv, float rv) {
   return lv + fixed(rv);
}
const fixed operator-(const fixed& lv, double& rv) {
   return lv - fixed(rv);
}
const fixed operator+(const fixed& lv, double rv) {
   return lv + fixed(rv);
}

const fixed operator*(const fixed& lv, const fixed& rv)
{
   return fixed::fromRaw(lv.fixed_mult(lv.value, rv.value));
}
const fixed operator/(const fixed& lv, const fixed& rv)
{
   return fixed::fromRaw(lv.fixed_div(lv.value, rv.value));
}
const fixed operator*(const fixed& lv, int rv)
{
   return lv * fixed(rv);
}
const fixed operator/(const fixed& lv, int rv)
{
   return lv / fixed(rv);
}
const fixed operator*(const fixed& lv, float rv)
{
   return lv * fixed(rv);
}
const fixed operator/(const fixed& lv, float rv)
{
   return lv / fixed(rv);
}
const fixed operator*(const fixed& lv, double rv)
{
   return lv * fixed(rv);
}
const fixed operator/(const fixed& lv, double rv)
{
   return lv / fixed(rv);
}
const fixed operator-(int lv, const fixed& rv)
{
  return fixed(lv) - rv;
}
const fixed operator+(int lv, const fixed& rv)
{
  return fixed(lv) + rv;
}
const fixed operator-(float lv, const fixed& rv)
{
  return fixed(lv) - rv;
}
const fixed operator+(float lv, const fixed& rv)
{
  return fixed(lv) + rv;
}
const fixed operator-(double lv, const fixed& rv)
{
  return fixed(lv) - rv;
}
const fixed operator+(double lv, const fixed& rv)
{
  return fixed(lv) + rv;
}
const fixed operator*(int lv, const fixed& rv)
{
  return fixed(lv) * rv;
}
const fixed operator/(int lv, const fixed& rv)
{
  return fixed(lv) / rv;
}
const fixed operator*(float lv, const fixed& rv)
{
  return fixed(lv) * rv;
}
const fixed operator/(float lv, const fixed& rv)
{
  return fixed(lv) / rv;
}
const fixed operator*(double lv, const fixed& rv)
{
  return fixed(lv) * rv;
}
const fixed operator/(double lv, const fixed& rv)
{
  return fixed(lv) / rv;
}
fixed& operator+=(fixed& lv, const fixed& rv) {
    lv = lv + rv;
    return lv;
}
fixed& operator-=(fixed& lv, const fixed& rv) {
    lv = lv - rv;
    return lv;
}
fixed& operator*=(fixed& lv, const fixed& rv) {
    lv = lv * rv;
    return lv;
}
fixed& operator/=(fixed& lv, const fixed& rv) {
    lv = lv / rv;
    return lv;
}