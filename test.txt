    fixed_type fixed_mult(fixed_type inp_1, fixed_type inp_2)
    {
        return (fixed_type)(((expand_type)inp_1 * (expand_type)inp_2) >> fractional_bits);
    }

    fixed_type fixed_add(fixed_type inp_1, fixed_type inp_2)
    {
        fixed_type inp_1_sign = inp_1 >> (fixed_type_bits - 1);
        fixed_type inp_2_sign = inp_2 >> (fixed_type_bits - 1);
        fixed_type add = inp_1 + inp_2;
        fixed_type add_sign = add >> (fixed_type_bits - 1);

        if (inp_1_sign != inp_2_sign)
        {
            return add;
        }
        else if (add_sign == inp_1_sign)
        {
            return add;
        }
        else if (add_sign == -1)
        {
            return ((1 << (fixed_type_bits - 2)) - 1 + (1 << (fixed_type_bits - 2)));
        }
        else if (add_sign == 1)
        {
            return (1 << (fixed_type_bits - 1));
        }
    }

    float fix_tostr_float_sprintf2(uint32_t value)
{
// сколько бит в дробной части
    const int fractBits = 16;
// экспонента числа с плавающей точкой
    uint_fast8_t exponent = 127 + fractBits - 9;
    if(value != 0)
    {
        if(value & 0xff000000)
        {
            while(value & 0xff000000)
            {
                value >>= 1;
                exponent ++;
            }
        }
        else
        {
            while((value & 0xff800000) == 0)
            {
                value <<= 1;
                exponent --;
            }
        }
        value &= 0x007fffff;
        value |= (uint32_t)exponent << 23;
    }
    float fvalue = *(float*)&value;
    return fvalue;
}